---
title: "dwplot: Dot-and-Whisker Plots of Regression Coefficients from Tidy Data Frames"
author: "Frederick Solt and Yue Hu"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: vignette_dwplot.bib
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{ASCII}
---

Graphs have long been known to be a more compact and effective means of conveying the results of regression models than tables [@Gelman2008; @Kastellec2007], but many researchers continue to list these results in tables. The reason, @Kastellec2007 surmised, is "simply put, it takes much greater effort to produce a quality graph than a table." The `dotwhisker` package provides a convenient way to create highly customizable dot-and-whisker plots for presenting and comparing the output of regression models. It can be used to plot estimates of coefficients or other quantities of interest (e.g., predicted probabilities) within a single model or across different models: the estimates are presented as dots and their confidence intervals as whiskers [see @Kastellec2007, 765-767].

Users can easily customize the number of models, the exact variables presented, and the inverval between the compared estimates based on their interests and presenting demands. Moreover, by outputting `ggplot` objects, `dotwhisker` allows users to easily further modify their graphs.

This vignette illustrates how to prepare regression results for input; basic use of `dwplot`, the package's function for creating dot-and-whisker plots; and a few examples of more advanced uses.


## Prepare a Data Frame for Graphing
Although other packages (e.g., `coefplot`) have the ability to draw dot-and-whisker plots, their functions take as inputs model objects, with the consequence that many models are not supported and plotting more than one model at a time is rarely possible.  The `dotwhisker` package avoids this limitation by taking as its input a data frame of estimates drawn from a model object rather than the model object itself.  Moreover, in the process of preparing a data frame of estimates, users have maximum flexibility in determining what results are (and are not) included in the plot. 

Extracting estimates from most model objects is straightforward, since many functions generate results that can be extracted by `coef()`. Further, the `broom` package [@Robinson2014] automates the process of extracting estimates for many common model objects. 

The valid input object for `dotwhisker` is a data frame including three columns: `term`, that is, the variable name; `estimate`, the regression coefficients or other quantity of interest; and `std.error`, the standard errors associated with these estimates. Again, for many common models, one can use `broom::tidy` to produce such a data frame of estimates. 

```{r message = F, warning=FALSE}
#Package preload
library(dplyr)
library(broom)
library(dotwhisker)

data(mtcars)

# regression compatible with tidy
m1 <- lm(mpg ~ wt + cyl + disp + gear, data = mtcars)
m1_df <- tidy(m1) # create data.frame of regression results
m1_df # available for dwplot
```

For model objects that are not compatible with `tidy`, one can simply extract the results and build the needed data frame. 

```{r}
# the ordinal regression model is not supported by tidy
m2 <- ordinal::clm(factor(gear) ~ wt + cyl + disp, data = mtcars)
m2_df <- coef(summary(m2)) %>% 
  data.frame() %>% 
  add_rownames("term") %>%
  rename(estimate = Estimate, std.error = Std..Error)
m2_df
```

During the process creating the data frame format, users are free to select or delete variables or to change their order. In many cases, for example, users will wish to consider omitting model intercepts as they are rarely theoretically interesting [see @Kastellec2007, 765]. Another often desireable manipulation is to standardize the scales of variables. @Gelman2008, for example, suggests rescaling ordinal and continuous predictors by two standard deviations to facilitate comparison with dichotomous predictors. Although this of course can be done before model estimation, it can be convenient to simply rescale the coefficients afterwards; the `by_2sd` function, which takes as arguments a data frame of estimates along with the original data frame upon which the model was based, automates this calculation.

```{r}
# Customize the input data frame
m1_df  # the original tidy data.frame

m1_df_sd <- tidy(m1) %>% by_2sd(mtcars)   # rescale the coefficients
m1_df_sel <- filter(m1_df_sd, term != "(Intercept)") # omit intercept
m1_df_sel2 <- arrange(m1_df_sel, term) # reorder the variables


m1_df_sd    # rescaled coefficients
m1_df_sel   # rescaled and intercept omitted
m1_df_sel2  # rescaled, intercept omitted, and variables reordered alphabetically
```

An input data frame can also be constructed from estimates of other quantities of interest, such as margins and predicted probabilities, rather than coefficients. 

```{r message= FALSE}
# Create a data.frame of marginal effects
library(mfx)
m3 <- logitmfx(formula = am ~ wt + cyl + disp, data = mtcars) 
m3_margin <- data.frame(m3$mfxest) %>% 
  add_rownames("term") %>% 
  rename(estimate = dF.dx, std.error = Std..Err.)
m3_margin
```



## Plot Estimates with `dwplot`

The `dotwhisker::dwplot` function is very easy to use. It takes just three arguments: `df`, `alpha`, and `dodge_size`.  The `df` argument is the data frame of estimates to be plotted (as described above). The `alpha` argument is the significance level of the confidence intervals to be spanned by the whiskers: its default value is .05, implying a 95% confidence interval. The `dodge_size` argument is used to adjust the space between the estimates of one variable when  multiple models are presented in a single plot.  Its default value will work fine, but more pleasing results can sometimes by achieved by it to lower values when the plotted results include a smaller number of predictors.

```{r fig.width= 7, warning= FALSE, message= FALSE}
dwplot(m1_df)
dwplot(m1_df, alpha = .01)  # using 99% CI
```

To omit intercepts, rescale coefficients, etc., no change in the use of `dwplot` is required: one simply modifies the data frame, as described above, that is passed to the function. 

```{r fig.width= 7, warning= FALSE, message= FALSE}
dwplot(m1_df_sel2)
```

Moreover, the output of `dwplot` is a `ggplot` object. Therefore, users are able to add or change any `ggplot` layers after calling `dwplot` to achieve the desired presentation.

```{r fig.width= 7, warning= FALSE, message= FALSE}
dwplot(m1_df_sel2) + 
    scale_y_discrete(breaks = 4:1, 
                      labels=c("Cylinders", "Displacement", "Gears", "Weight")) +
    theme_bw() + xlab("Standardized Coefficient") + ylab("") +
    geom_vline(xintercept = 0, colour = "grey60", linetype = 2) +
    ggtitle("Predicting Gas Mileage") +
    theme(plot.title = element_text(face="bold"), legend.position="none") 
```



## Compare Across Models 
An additional advantage of`dwplot` over alternative solutions is that it can be used to create plots that present multiple models---across different samples or specifications---in little space while also facilitating cross-model comparisons. To do this, one first needs to append the data frame of estimates from the new model to that of the old model and create an additional column `model` that identifies the two models.

```{r fig.width= 7, fig.height=5, warning=FALSE, message=FALSE}
# Run model on subsets of data, save results as tidy df, drop intercept, and make model variable
by_trans <- mtcars %>% group_by(am) %>%
    do(tidy(lm(mpg ~ wt + cyl + disp + gear, data = .))) %>%
    filter(term != "(Intercept)") %>% rename(model=am)

by_trans

dwplot(by_trans, dodge_size = .05) +
    scale_y_discrete(breaks = 4:1, labels=c("Weight", "Cylinders", "Displacement", "Gears")) +
    theme_bw() + xlab("Coefficient Estimate") + ylab("") +
    geom_vline(xintercept = 0, colour = "grey60", linetype = 2) +
    ggtitle("Predicting Gas Mileage by Transmission Type") +
    theme(plot.title = element_text(face="bold"),
          legend.justification=c(0, 0), legend.position=c(0, 0),
          legend.background = element_rect(colour="grey80"),
          legend.title.align = .5) +
    scale_colour_grey(start = .4, end = .8,
                      name = "Transmission",
                      breaks = c(0, 1),
                      labels = c("Automatic", "Manual"))

```

To include models with different predictors, one must ensure the `term`s are identical across all of the models.  That is, the data frame for each model must include a row for every predictor included in any of the models, in the same order, regardless of whether the predictor is actually included in a particular model.  Quantities not estimated in a particular model should be assigned a value of `NA`.

```{r fig.width= 7, fig.height=7, warning=FALSE, message=FALSE}
# Estimate three models
m4 <- lm(mpg ~ wt + cyl + disp + gear, data = mtcars) # same as m1
m5 <- update(m4, . ~ . + hp) # add another predictor
m6 <- update(m5, . ~ . + am) # and another 

# Tidy estimates, rescale, and omit intercepts
prep_456 <- . %>% tidy() %>% by_2sd(mtcars) %>% filter(term != "(Intercept)")

m4_df <- prep_456(m4)
m5_df <- prep_456(m5)
m6_df <- prep_456(m6)

# Ensure all data.frames include rows for all of the predictors, in the same order
# Include NAs for any quantities not estimated in a particular model
m4_df <- rbind(m4_df, c("hp", rep(NA, times = ncol(m4_df) - 1)),
               c("am", rep(NA, times = ncol(m4_df) - 1)))
m5_df <- rbind(m5_df, c("am", rep(NA, times = ncol(m5_df) - 1)))

# Add model variable to all data frames
m4_df <- mutate(m4_df, model = "Model 4")
m5_df <- mutate(m5_df, model = "Model 5")
m6_df <- mutate(m6_df, model = "Model 6")

m456_df <- rbind(m4_df, m5_df, m6_df)

dwplot(m456_df, dodge_size = .08) +
     scale_y_discrete(breaks = 6:1, 
                      labels=c("Weight", "Cylinders", "Displacement", 
                               "Gears", "Horsepower", "Manual")) +
     theme_bw() + xlab("Coefficient Estimate") + ylab("") +
     geom_vline(xintercept = 0, colour = "grey60", linetype = 2) +
     ggtitle("Predicting Gas Mileage") +
     theme(plot.title = element_text(face="bold"),
           legend.justification=c(1, 1), legend.position=c(1, 1),
           legend.background = element_rect(colour="grey80"),
           legend.title = element_blank()) 
```

It is frequently desirable to convey to an audience that the predictors in a model depicted in a dot-and-whisker plot form groups of some sort.  This can be achieved by passing the finalized plot to the `add_brackets` function.  Note that `add_brackets` outputs a `gtable` rather than a `ggplot` object.  Therefore, the output is displayed using `grid.draw` and saved, at present, by calling a device.

```{r fig.width= 7, fig.height=7, warning=FALSE, message=FALSE}
# Reorder predictors into groups
ordered_vars <- c("wt", "cyl", "disp", "hp", "gear", "am")
m456_df <- m456_df %>% mutate(term =  factor(term, levels = ordered_vars)) %>%
  group_by(model) %>% arrange(term) 

# Save finalized plot to an object (note reordered labels to match reordered predictors)
p456 <- dwplot(m456_df, dodge_size = .08) +
     scale_y_discrete(breaks = 6:1, 
                      labels=c("Weight", "Cylinders", "Displacement", 
                               "Horsepower", "Gears", "Manual")) +
     theme_bw() + xlab("Coefficient Estimate") + ylab("") +
     geom_vline(xintercept = 0, colour = "grey60", linetype = 2) +
     ggtitle("Predicting Gas Mileage") +
     theme(plot.title = element_text(face="bold"),
           legend.justification=c(1, 1), legend.position=c(1, 1),
           legend.background = element_rect(colour="grey80"),
           legend.title = element_blank()) 

# Create list of brackets (label, topmost incl. predictor, bottommost incl. predictor)
three_brackets <- list(c("Overall", "wt", "wt"), c("Engine", "cyl", "hp"),
                       c("Transmission", "gear", "am"))

g456 <- p456 %>% add_brackets(three_brackets)

grid.draw(g456)  # to display

# pdf("plot.pdf")  # to save (not run)
# grid.draw(g456)
# dev.off()
```

An alternate use of dot-and-whisker plots is to compare the estimated coefficients for a single predictor across many models or datasets: Andrew Gelman calls such plots "[the secret weapon](http://andrewgelman.com/2005/03/07/the_secret_weap/)."  They are easy to make with `dwplot`.

```{r fig.width= 7, fig.height=7, warning=FALSE, message=FALSE}
data(diamonds)

by_clarity <- diamonds %>% group_by(clarity) %>%
    do(tidy(lm(price ~ carat + cut + color, data = .))) %>% rename(model=clarity)

carat_results <- by_clarity %>% filter(term=="carat") %>% dplyr::select(-term) %>%
    rename(term=model)

dwplot(carat_results) +
    xlab("Estimated Coefficient (Dollars)") + ylab("Diamond Clarity") +
    ggtitle("Estimated Coefficients for Diamond Size Across Clarity Grades") +
    theme(plot.title = element_text(face="bold"))
```

A final means of comparing many model results is through a "small multiple" plot.  Small multiple plots present estimates in multiple panels, one for each variable: they are effectively a stack of "secret weapon" plots [see @Kastellec2007, 766].  To create a small multiple with `dwplot`, we first need to split the orginal estimate dataset into pieces in which there are estimates based on mutliple conditions but only for one variable. The `dotwhisker` package includes the function `sm_mult_setup` to conveniently split a tidy data frame into a list of single variable datasets. Then, with the loop funciton, one can create a list of `dwplot`s for each dataset. Users can freely extract several or all the plots into one page to be the small multiple plot. The `multiplot` function by [\emph{Cookbook for R}](http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/) provide an easy way to combine the plots, which we also include in the `dotwhisker` package. 

```{r fig.width= 7, fig.height=7, warning=FALSE, message=FALSE}
data("diamonds")
# combine the "Fair" into "Good" just for presenting convenince.
diamonds$cut[diamonds$cut == "Fair"] <- "Good" 


# run analyses for groups with different cutting quality
by_cut <- diamonds %>% group_by(cut) %>%
  do(tidy(lm(price ~ depth + table, data = .))) %>% rename(model=cut) 
 
# create a binary variable identifying if a diamond is a high-level or low-level cutting one.
by_cut$top <- 0
by_cut$top[by_cut$model %in% c("Premium", "Ideal")] <- 1
by_cut$model <- rep(c("low-level", "high-level"), each = 3, times = 2)


# Creating the list of tidy data.frame.
smul_list <- smul(by_cut, "term", "top")


# Create the small multiple plot.
smul_plots <- list()

for(i in seq(length(smul_list))){
  smul_plots[[i]] <- dwplot(smul_list[[i]]) + 
    ylab("") + xlab(names(smul_list)[i]) + 
    geom_vline(xintercept = 0, colour = "grey60", linetype = 2) + 
    theme_bw() +
    theme(legend.position = "none") +
    scale_y_discrete(limits = c("low-level", "high-level")) + coord_flip()
}


multiplot(plotlist = smul_plots, cols = 1)

```



## Conclusion

The `dotwhisker` package provides a flexible and convenient way to visualize and compare estimates across various models. This vignette offers an overview of its use and features. We encourage users to consult the help files for more details. 

The development of the package is ongoing. Please contact us with any questions, bug reports, and comments.

## Affiliation

Frederick Solt

Department of Political Science,

University of Iowa, 

324 Schaeffer Hall,

20 E Washington St, Iowa City, IA, 52242

Email: <frederick-solt@uiowa.edu>

Website: <http://myweb.uiowa.edu/fsolt>

<br></br>

Yue Hu

Department of Political Science,

University of Iowa, 

313 Schaeffer Hall,

20 E Washington St, Iowa City, IA, 52242

Email: <yue-hu-1@uiowa.edu>

Website: <http://clas.uiowa.edu/polisci/people/yue-hu>

## References

